ğŸ—“ï¸ PLAN DE ESTUDIO ACTUALIZADO (4 DÃAS)
âœ… DÃ­a 1 â€“ Fundamentos y pruebas completas del microservicio
ğŸ¯ Objetivo: Entender la arquitectura de un microservicio Spring Boot con SQLite y practicar todos los endpoints. Configurar pruebas y validaciones.

ğŸ§± Estructura y funcionalidad:
âœ… RevisiÃ³n completa de capas (entity, repository, service, logic, controller).
âœ… ExplicaciÃ³n profunda de cada anotaciÃ³n y rol por capa.
âœ… ConexiÃ³n verificada con SQLite (DB Browser).

ğŸ” Endpoints con Postman:
âœ… Pruebas GET, GET /id, POST, DELETE.
âœ… Confirmado con SQLite que los datos se insertan y borran.

ğŸ” Seguridad:
âœ… DesactivaciÃ³n temporal de Spring Security para pruebas.

ğŸ§ª Pruebas unitarias:
âœ… JUnit para mÃ©todos de servicio (getAll, getById, create, delete).
âœ… Mockito para simular el repositorio (sin acceder a la base real).
ğŸ“Œ Nota: Estas pruebas son reutilizables para futuros microservicios.
ğŸ“Œ Las corriste desde IntelliJ para observar los resultados en tiempo real.
ğŸ“Œ Aprendiste que son esenciales para integrarse en pipelines CI/CD.

âœ… Validaciones:
âœ… Se agregÃ³ @NotBlank, @Size al CustomerRequest.
âœ… Se usÃ³ @Valid en el controller.
âœ… Se explicÃ³ cÃ³mo responde el sistema si el input es invÃ¡lido.
ğŸ“Œ Ejemplo: ID vacÃ­o lanza error con mensaje personalizado.

ğŸ”œ DÃ­a 2 â€“ Spring Security, Docker y conexiÃ³n a GitHub
ğŸ¯ Objetivo: Proteger el microservicio, empaquetarlo como contenedor y preparar flujo de trabajo en Git.

ğŸ”’ Seguridad:
âœ…  Activar Spring Security.
âœ…  Configurar autenticaciÃ³n bÃ¡sica (con propiedades o clase de seguridad).
âœ…  Probar endpoints protegidos desde Postman (401 si no se envÃ­a auth, 200 si sÃ­).

ğŸ³ Docker:
âœ…  Crear Dockerfile.
âœ…  Construir imagen.
âœ…  Ejecutar contenedor local.
âœ…  Confirmar acceso a endpoints dentro del contenedor.

ğŸŒ Git y GitHub:
âœ…  Crear repositorio.
âœ…  Agregar .gitignore.
âœ…  Primeros commits (1 por feature/fase lÃ³gica).
âœ…  Subida a GitHub.
âœ…  Buenas prÃ¡cticas: mensajes como add: Dockerfile, fix: Customer null bug, etc.

ğŸ³ Docker hub 
âœ… Docker login 
âœ… Crear un docker compose yml
âœ… subirlo a docker hub con docker push 
âœ… automatizarlo con docker compose 

versionado de codigo 
ğŸ”²subir nuevamente el proyecto ahora con el yml en una nueva rama y luego unirlo a la rama principal


ğŸ“Œ AprenderÃ¡s a trabajar con ramas (ej: feature/security, feature/docker).

ğŸ—“ï¸ DÃ­a 3 â€“ SQL y optimizaciÃ³n de datos (ACTUALIZADO)
ğŸ¯ Objetivo: Repasar SQL clave que puedes necesitar entender en producciÃ³n, y cÃ³mo se relaciona con consultas automÃ¡ticas de JPA. TambiÃ©n comprender herramientas mÃ¡s avanzadas como triggers.

ğŸ“¦ Buenas prÃ¡cticas SQL:
ğŸ”² Evitar autocommits en scripts (usar BEGIN TRANSACTION, COMMIT de forma consciente).
ğŸ”² Hacer commits manuales cuando completes una operaciÃ³n consistente (ej: insertar en varias tablas relacionadas).
ğŸ”² Tener cuidado con operaciones peligrosas: DELETE sin WHERE, UPDATE masivo sin backup.

ğŸ§  Repaso general:
ğŸ”² JOINS (INNER, LEFT, RIGHT)
ğŸ”² Subconsultas (WHERE IN, EXISTS, etc.)
ğŸ”² GROUP BY y HAVING
ğŸ”² Ãndices (cÃ³mo y cuÃ¡ndo crearlos; afectan performance de SELECT)
ğŸ”² Vistas (VIEW) (para encapsular lÃ³gica compleja)
ğŸ”² Procedimientos almacenados (Ãºtiles en lÃ³gica pesada del lado del DB, aunque menos usados con JPA)
ğŸ”² TRIGGERS (nuevo): Â¿QuÃ© es un trigger?
Es una funciÃ³n que se ejecuta automÃ¡ticamente cuando ocurre un evento (ej: INSERT, UPDATE, DELETE) en una tabla.
Â¿Para quÃ© sirve?

Auditar cambios (guardar historial en otra tabla).
Validar reglas del negocio.
Sincronizar datos entre tablas.


ğŸ”œ DÃ­a 4 â€“ Refuerzo general y adaptaciÃ³n a cÃ³digo legado
ğŸ¯ Objetivo: Estar preparado para leer, entender y modificar cÃ³digo de otros developers.

ğŸ§  AdaptaciÃ³n:
ğŸ”² Leer el microservicio como si fuera legado.
ğŸ”² Identificar buenas/malas prÃ¡cticas.
ğŸ”² Hacer pequeÃ±as mejoras: logging, validaciones, refactorizaciÃ³n.

ğŸ§° Herramientas de productividad:
ğŸ”² Atajos Ãºtiles de IntelliJ (generar setters, navegar, refactorizar rÃ¡pido).
ğŸ”² Revisar uso de plugins Ãºtiles para debugging, Spring, etc.

ğŸ”² VerificaciÃ³n final: correr el microservicio con seguridad activada y tests ejecutando correctamente.

ğŸ” OPCIONAL â€“ Circuit Breaker con Resilience4j
ğŸ¯ Objetivo: Evitar que un microservicio falle en cascada si otro estÃ¡ caÃ­do.

ğŸ”§ PreparaciÃ³n:
ğŸ”² Crear microservicio de orders (secundario).
ğŸ”² Simular delay o caÃ­da.
ğŸ”² AÃ±adir resilience4j-spring-boot3 al microservicio de customers.

ğŸ›¡ï¸ ImplementaciÃ³n:
ğŸ”² Usar @CircuitBreaker, @Retry, @FallbackMethod.
ğŸ”² Probar cÃ³mo responde el sistema si orders falla.
ğŸ”² Revisar logs para verificar comportamiento del patrÃ³n.

ğŸ“ Notas adicionales:
âœ… Lombok:
Elimina cÃ³digo repetitivo (getters, setters, constructores).

Mejora legibilidad sin cambiar comportamiento.

âœ… Buenas prÃ¡cticas Git:
Commit por funcionalidad terminada (no cada lÃ­nea).

Usa ramas para features nuevas.

Mensajes descriptivos: add: customer endpoint, refactor: service layer.




